
unit ObispoNumero;

interface

uses
  ObispoMate, Math;

const
  Dec : string = '0123456789ABCDEF';

  Dic : Array[1..4,1..9] of String=
  (('I','II','III','IV','V','VI','VII','VIII','IX'),
  ('X','XX','XXX','XL','L','LX','LXX','LXXX','CX'),
  ('C','CC','CCC','CD','D','DC','DCC','DCCC','CM'),
  ('M','MM','MMM','Mv','v','vM','vMM','vMMM','vv'));

Type

  Numero = class
    private

      Value : cardinal;
    public

      Constructor Create;

      Procedure SetValue(num : cardinal);
      Procedure Anadir(dig : byte);
      Procedure EliminarPos(pos : byte);
      Procedure EliminarDig(num : byte);
      Procedure Insertar(dig, pos : byte);
      Procedure Modificar(dig, pos : byte);
      Procedure SeparaPares;
      Procedure OrdenAscendente;
      Procedure OrdenDescendente;
      Procedure SuperInsertar(Buscado, Num: Cardinal);

      Function GetValue : cardinal;
      Function Digito(pos : byte) : byte;
      Function NumDig : byte;
      Function SumaDigitos : cardinal;
      Function NumMayor : byte;
      Function NumMenor : byte;
      Function Frecuencia(num : byte) : cardinal;
      Function Conversor(base : byte) : string;
      Function Romano : string;
      Function ToDecim(Num: String; Base: Cardinal): Cardinal;

      Function SuperBuscar(Num: Cardinal): Boolean;
  end;

implementation
Uses
  ObispoCadena;

Constructor Numero.Create;
begin

end;

{Procedimientos}

Procedure Numero.SetValue(num: Cardinal);
begin
  Value := num;
end;

Procedure Numero.Anadir(dig: Byte);
begin
  Value := Value * 10 + dig;
end;

Procedure Numero.EliminarPos(pos: Byte);
begin
  Value := Value div Potencia(10,pos) * Potencia(10,pos - 1) + Value mod Potencia(10,pos - 1);
end;

Procedure Numero.EliminarDig(num: Byte);
var
  i : byte;
begin
  i := 1;
  while i <= NumDig do
  begin
    if Digito(i) = num then
      EliminarPos(i)
    else
      i := i + 1;
  end;
end;

Procedure Numero.Insertar(dig: Byte; pos: Byte);
begin
  Value := ((Value div Potencia(10,pos - 1)) * 10 + dig) * Potencia(10,pos - 1) + Value mod Potencia(10,pos-1);
end;

Procedure Numero.Modificar(dig: Byte; pos: Byte);
begin
  Value := ((Value div Potencia(10,pos)) * 10 + dig) * Potencia(10,pos - 1) + Value mod Potencia(10, pos-1);
end;

Procedure Numero.SeparaPares;
var
  i : byte;
  d : byte;
begin
  for i := 1 to NumDig do
  begin
    d := Digito(i);
    if d mod 2 = 0 then
    begin
      EliminarPos(i);
      Anadir(d);
    end;
  end;
end;

Procedure Numero.OrdenAscendente;
var
  i : byte;
  j : byte;
  dig : byte;
begin
  for j := 1 to NumDig - 1 do
  for i := 1 to NumDig - 1 do
    if Digito(i) < Digito(i + 1) then
    begin
      dig := Digito(i + 1);
      EliminarPos(i + 1);
      Anadir(dig);
    end;
end;

Procedure Numero.OrdenDescendente;
var
  i : byte;
  j : byte;
  dig : byte;
begin
  for j := 1 to NumDig - 1 do
  for i := 1 to NumDig - 1 do
    if Digito(i) > Digito(i + 1) then
    begin
      dig := Digito(i + 1);
      EliminarPos(i + 1);
      Anadir(dig);
    end;
end;

Procedure Numero.SuperInsertar(Buscado, Num: Cardinal);
Begin

End;

{Funciones}

Function Numero.GetValue: Cardinal;
begin
  GetValue := Value;
end;

Function Numero.Digito(pos: Byte): Byte;
begin
  Digito := (Value div Potencia(10,pos - 1)) mod 10;
end;

Function Numero.NumDig: Byte;
begin
  Numdig := trunc(log10(value)) + 1;
end;

Function Numero.SumaDigitos: Cardinal;
var
  i : byte;
  suma : cardinal;
begin
  suma := 0;
  for i:=1 to NumDig do
    suma := suma + Digito(i);
  SumaDigitos := suma;
end;

Function Numero.NumMayor: Byte;
var
  i : byte;
  mayor : byte;
begin
  mayor := 0;
  for i := 1 to NumDig do
    if Digito(i) > mayor then
      mayor := Digito(i);
  NumMayor := mayor;
end;

Function Numero.NumMenor: Byte;
var
  i : byte;
  menor : byte;
begin
  menor := 9;
  for i := 1 to NumDig do
    if Digito(i) < menor then
      menor := Digito(i);
  NumMenor := menor;
end;

Function Numero.Frecuencia(num: Byte): Cardinal;
var
  i : byte;
  fre : cardinal;
begin
  fre := 0;
  for i := 1 to NumDig do
    if Digito(i) = num then
      fre := fre + 1;
  Frecuencia := fre;
end;

Function Numero.Conversor(base: Byte): string;
var
  n : cardinal;
  d : byte;
  NewNum : string;
begin
  n := Value;
  while n > 0 do
  begin
    d := n mod base;
    NewNum := Dec[d + 1] + NewNum;
    n := n div base;
  end;
  Conversor := NewNum;
end;

Function Numero.Romano: string;
var
  n : cardinal;
  i, dig : byte;
  roman : string;
begin
  roman := '';
  n := value;
  i := 1;
  while n > 0 do
  begin
    dig := n mod 10;
    if dig > 0 then
      roman := Dic[i, dig] + roman;
    n := n div 10;
    i := i + 1;
  end;
  Romano := roman;
end;

Function Numero.ToDecim(Num: String; Base: Cardinal): Cardinal;
Var
  i, j, Decim: Cardinal;
  obj: Cadena;
Begin
  obj := Cadena.Create;
  obj.SetCadena(Dec);
  Decim := 0;
  i := Length(Num);
  j := 1;
  while i >= 1 do
  begin
    Decim := Decim + (obj.BuscarChar(Num[i]) - 1)*Potencia(Base, j - 1);
    i := i - 1;
    j := j + 1;
  end;
  ToDecim := Decim;
End;

Function Numero.SuperBuscar(Num: Cardinal): Boolean;
Begin

End;

end.
